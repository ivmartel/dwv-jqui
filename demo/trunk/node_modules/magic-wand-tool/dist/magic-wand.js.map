{"version":3,"file":"magic-wand.js","sources":["../src/MagicWand.js"],"sourcesContent":["ï»¿    \r\nvar MagicWand = (function () {\r\n    var lib = {};\r\n\r\n    /** Create a binary mask on the image by color threshold\r\n      * Algorithm: Scanline flood fill (http://en.wikipedia.org/wiki/Flood_fill)\r\n      * @param {Object} image: {Uint8Array} data, {int} width, {int} height, {int} bytes\r\n      * @param {int} x of start pixel\r\n      * @param {int} y of start pixel\r\n      * @param {int} color threshold\r\n      * @param {Uint8Array} mask of visited points (optional) \r\n      * @param {boolean} [includeBorders=false] indicate whether to include borders pixels\r\n      * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      */\r\n    lib.floodFill = function(image, px, py, colorThreshold, mask, includeBorders) {\r\n        return includeBorders\r\n            ? floodFillWithBorders(image, px, py, colorThreshold, mask)\r\n            : floodFillWithoutBorders(image, px, py, colorThreshold, mask);\r\n    };\r\n\r\n    function floodFillWithoutBorders(image, px, py, colorThreshold, mask) {\r\n\r\n        var c, x, newY, el, xr, xl, dy, dyl, dyr, checkY,\r\n            data = image.data,\r\n            w = image.width,\r\n            h = image.height,\r\n            bytes = image.bytes, // number of bytes in the color\r\n            maxX = -1, minX = w + 1, maxY = -1, minY = h + 1,\r\n            i = py * w + px, // start point index in the mask data\r\n            result = new Uint8Array(w * h), // result mask\r\n            visited = new Uint8Array(mask ? mask : w * h); // mask of visited points\r\n\r\n        if (visited[i] === 1) return null;\r\n\r\n        i = i * bytes; // start point index in the image data\r\n        var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)\r\n\r\n        var stack = [{ y: py, left: px - 1, right: px + 1, dir: 1 }]; // first scanning line\r\n        do {\r\n            el = stack.shift(); // get line for scanning\r\n\r\n            checkY = false;\r\n            for (x = el.left + 1; x < el.right; x++) {\r\n                dy = el.y * w;\r\n                i = (dy + x) * bytes; // point index in the image data\r\n\r\n                if (visited[dy + x] === 1) continue; // check whether the point has been visited\r\n                // compare the color of the sample\r\n                c = data[i] - sampleColor[0]; // check by red\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n                c = data[i + 1] - sampleColor[1]; // check by green\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n                c = data[i + 2] - sampleColor[2]; // check by blue\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n\r\n                checkY = true; // if the color of the new point(x,y) is similar to the sample color need to check minmax for Y \r\n\r\n                result[dy + x] = 1; // mark a new point in mask\r\n                visited[dy + x] = 1; // mark a new point as visited\r\n\r\n                xl = x - 1;\r\n                // walk to left side starting with the left neighbor\r\n                while (xl > -1) {\r\n                    dyl = dy + xl;\r\n                    i = dyl * bytes; // point index in the image data\r\n                    if (visited[dyl] === 1) break; // check whether the point has been visited\r\n                    // compare the color of the sample\r\n                    c = data[i] - sampleColor[0]; // check by red\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 1] - sampleColor[1]; // check by green\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 2] - sampleColor[2]; // check by blue\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n\r\n                    result[dyl] = 1;\r\n                    visited[dyl] = 1;\r\n\r\n                    xl--;\r\n                }\r\n                xr = x + 1;\r\n                // walk to right side starting with the right neighbor\r\n                while (xr < w) {\r\n                    dyr = dy + xr;\r\n                    i = dyr * bytes; // index point in the image data\r\n                    if (visited[dyr] === 1) break; // check whether the point has been visited\r\n                    // compare the color of the sample\r\n                    c = data[i] - sampleColor[0]; // check by red\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 1] - sampleColor[1]; // check by green\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 2] - sampleColor[2]; // check by blue\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n\r\n                    result[dyr] = 1;\r\n                    visited[dyr] = 1;\r\n\r\n                    xr++;\r\n                }\r\n\r\n                // check minmax for X\r\n                if (xl < minX) minX = xl + 1;\r\n                if (xr > maxX) maxX = xr - 1;\r\n\r\n                newY = el.y - el.dir;\r\n                if (newY >= 0 && newY < h) { // add two scanning lines in the opposite direction (y - dir) if necessary\r\n                    if (xl < el.left) stack.push({ y: newY, left: xl, right: el.left, dir: -el.dir }); // from \"new left\" to \"current left\"\r\n                    if (el.right < xr) stack.push({ y: newY, left: el.right, right: xr, dir: -el.dir }); // from \"current right\" to \"new right\"\r\n                }\r\n                newY = el.y + el.dir;\r\n                if (newY >= 0 && newY < h) { // add the scanning line in the direction (y + dir) if necessary\r\n                    if (xl < xr) stack.push({ y: newY, left: xl, right: xr, dir: el.dir }); // from \"new left\" to \"new right\"\r\n                }\r\n            }\r\n            // check minmax for Y if necessary\r\n            if (checkY) {\r\n                if (el.y < minY) minY = el.y;\r\n                if (el.y > maxY) maxY = el.y;\r\n            }\r\n        } while (stack.length > 0);\r\n\r\n        return {\r\n            data: result,\r\n            width: image.width,\r\n            height: image.height,\r\n            bounds: {\r\n                minX: minX,\r\n                minY: minY,\r\n                maxX: maxX,\r\n                maxY: maxY\r\n            }\r\n        };\r\n    };\r\n\r\n    function floodFillWithBorders(image, px, py, colorThreshold, mask) {\r\n\r\n        var c, x, newY, el, xr, xl, dy, dyl, dyr, checkY,\r\n            data = image.data,\r\n            w = image.width,\r\n            h = image.height,\r\n            bytes = image.bytes, // number of bytes in the color\r\n            maxX = -1, minX = w + 1, maxY = -1, minY = h + 1,\r\n            i = py * w + px, // start point index in the mask data\r\n            result = new Uint8Array(w * h), // result mask\r\n            visited = new Uint8Array(mask ? mask : w * h); // mask of visited points\r\n\r\n        if (visited[i] === 1) return null;\r\n\r\n        i = i * bytes; // start point index in the image data\r\n        var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)\r\n\r\n        var stack = [{ y: py, left: px - 1, right: px + 1, dir: 1 }]; // first scanning line\r\n        do {\r\n            el = stack.shift(); // get line for scanning\r\n\r\n            checkY = false;\r\n            for (x = el.left + 1; x < el.right; x++) {\r\n                dy = el.y * w;\r\n                i = (dy + x) * bytes; // point index in the image data\r\n\r\n                if (visited[dy + x] === 1) continue; // check whether the point has been visited\r\n\r\n                checkY = true; // if the color of the new point(x,y) is similar to the sample color need to check minmax for Y \r\n\r\n                result[dy + x] = 1; // mark a new point in mask\r\n                visited[dy + x] = 1; // mark a new point as visited\r\n\r\n                // compare the color of the sample\r\n                c = data[i] - sampleColor[0]; // check by red\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n                c = data[i + 1] - sampleColor[1]; // check by green\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n                c = data[i + 2] - sampleColor[2]; // check by blue\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n\r\n                xl = x - 1;\r\n                // walk to left side starting with the left neighbor\r\n                while (xl > -1) {\r\n                    dyl = dy + xl;\r\n                    i = dyl * bytes; // point index in the image data\r\n                    if (visited[dyl] === 1) break; // check whether the point has been visited\r\n\r\n                    result[dyl] = 1;\r\n                    visited[dyl] = 1;\r\n                    xl--;\r\n\r\n                    // compare the color of the sample\r\n                    c = data[i] - sampleColor[0]; // check by red\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 1] - sampleColor[1]; // check by green\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 2] - sampleColor[2]; // check by blue\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                }\r\n                xr = x + 1;\r\n                // walk to right side starting with the right neighbor\r\n                while (xr < w) {\r\n                    dyr = dy + xr;\r\n                    i = dyr * bytes; // index point in the image data\r\n                    if (visited[dyr] === 1) break; // check whether the point has been visited\r\n\r\n                    result[dyr] = 1;\r\n                    visited[dyr] = 1;\r\n                    xr++;\r\n\r\n                    // compare the color of the sample\r\n                    c = data[i] - sampleColor[0]; // check by red\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 1] - sampleColor[1]; // check by green\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 2] - sampleColor[2]; // check by blue\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                }\r\n\r\n                // check minmax for X\r\n                if (xl < minX) minX = xl + 1;\r\n                if (xr > maxX) maxX = xr - 1;\r\n\r\n                newY = el.y - el.dir;\r\n                if (newY >= 0 && newY < h) { // add two scanning lines in the opposite direction (y - dir) if necessary\r\n                    if (xl < el.left) stack.push({ y: newY, left: xl, right: el.left, dir: -el.dir }); // from \"new left\" to \"current left\"\r\n                    if (el.right < xr) stack.push({ y: newY, left: el.right, right: xr, dir: -el.dir }); // from \"current right\" to \"new right\"\r\n                }\r\n                newY = el.y + el.dir;\r\n                if (newY >= 0 && newY < h) { // add the scanning line in the direction (y + dir) if necessary\r\n                    if (xl < xr) stack.push({ y: newY, left: xl, right: xr, dir: el.dir }); // from \"new left\" to \"new right\"\r\n                }\r\n            }\r\n            // check minmax for Y if necessary\r\n            if (checkY) {\r\n                if (el.y < minY) minY = el.y;\r\n                if (el.y > maxY) maxY = el.y;\r\n            }\r\n        } while (stack.length > 0);\r\n\r\n        return {\r\n            data: result,\r\n            width: image.width,\r\n            height: image.height,\r\n            bounds: {\r\n                minX: minX,\r\n                minY: minY,\r\n                maxX: maxX,\r\n                maxY: maxY\r\n            }\r\n        };\r\n    };\r\n\r\n    /** Apply the gauss-blur filter to binary mask\r\n      * Algorithms: http://blog.ivank.net/fastest-gaussian-blur.html\r\n      * http://www.librow.com/articles/article-9\r\n      * http://elynxsdk.free.fr/ext-docs/Blur/Fast_box_blur.pdf\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @param {int} blur radius\r\n      * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      */\r\n    lib.gaussBlur = function(mask, radius) {\r\n\r\n        var i, k, k1, x, y, val, start, end,\r\n            n = radius * 2 + 1, // size of the pattern for radius-neighbors (from -r to +r with the center point)\r\n            s2 = radius * radius,\r\n            wg = new Float32Array(n), // weights\r\n            total = 0, // sum of weights(used for normalization)\r\n            w = mask.width,\r\n            h = mask.height,\r\n            data = mask.data,\r\n            minX = mask.bounds.minX,\r\n            maxX = mask.bounds.maxX,\r\n            minY = mask.bounds.minY,\r\n            maxY = mask.bounds.maxY;\r\n\r\n        // calc gauss weights\r\n        for (i = 0; i < radius; i++) {\r\n            var dsq = (radius - i) * (radius - i);\r\n            var ww = Math.exp(-dsq / (2.0 * s2)) / (2 * Math.PI * s2);\r\n            wg[radius + i] = wg[radius - i] = ww;\r\n            total += 2 * ww;\r\n        }\r\n        // normalization weights\r\n        for (i = 0; i < n; i++) {\r\n            wg[i] /= total;\r\n        }\r\n\r\n        var result = new Uint8Array(w * h), // result mask\r\n            endX = radius + w,\r\n            endY = radius + h;\r\n\r\n        //walk through all source points for blur\r\n        for (y = minY; y < maxY + 1; y++)\r\n            for (x = minX; x < maxX + 1; x++) {\r\n                val = 0;\r\n                k = y * w + x; // index of the point\r\n                start = radius - x > 0 ? radius - x : 0;\r\n                end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\r\n                k1 = k - radius;\r\n                // walk through x-neighbors\r\n                for (i = start; i < end; i++) {\r\n                    val += data[k1 + i] * wg[i];\r\n                }\r\n                start = radius - y > 0 ? radius - y : 0;\r\n                end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\r\n                k1 = k - radius * w;\r\n                // walk through y-neighbors\r\n                for (i = start; i < end; i++) {\r\n                    val += data[k1 + i * w] * wg[i];\r\n                }\r\n                result[k] = val > 0.5 ? 1 : 0;\r\n            }\r\n\r\n        return {\r\n            data: result,\r\n            width: w,\r\n            height: h,\r\n            bounds: {\r\n                minX: minX,\r\n                minY: minY,\r\n                maxX: maxX,\r\n                maxY: maxY\r\n            }\r\n        };\r\n    };\r\n\r\n    /** Create a border index array of boundary points of the mask with radius-neighbors\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @param {int} blur radius\r\n      * @param {Uint8Array} visited: mask of visited points (optional) \r\n      * @return {Array} border index array of boundary points with radius-neighbors (only points need for blur)\r\n      */\r\n    function createBorderForBlur(mask, radius, visited) {\r\n\r\n        var x, i, j, y, k, k1, k2,\r\n            w = mask.width,\r\n            h = mask.height,\r\n            data = mask.data,\r\n            visitedData = new Uint8Array(data),\r\n            minX = mask.bounds.minX,\r\n            maxX = mask.bounds.maxX,\r\n            minY = mask.bounds.minY,\r\n            maxY = mask.bounds.maxY,\r\n            len = w * h,\r\n            temp = new Uint8Array(len), // auxiliary array to check uniqueness\r\n            border = [], // only border points\r\n            x0 = Math.max(minX, 1),\r\n            x1 = Math.min(maxX, w - 2),\r\n            y0 = Math.max(minY, 1),\r\n            y1 = Math.min(maxY, h - 2);\r\n\r\n        if (visited && visited.length > 0) {\r\n            // copy visited points (only \"black\")\r\n            for (k = 0; k < len; k++) {\r\n                if (visited[k] === 1) visitedData[k] = 1;\r\n            }\r\n        }\r\n\r\n        // walk through inner values except points on the boundary of the image\r\n        for (y = y0; y < y1 + 1; y++)\r\n            for (x = x0; x < x1 + 1; x++) {\r\n                k = y * w + x;\r\n                if (data[k] === 0) continue; // \"white\" point isn't the border\r\n                k1 = k + w; // y + 1\r\n                k2 = k - w; // y - 1\r\n                // check if any neighbor with a \"white\" color\r\n                if (visitedData[k + 1] === 0 || visitedData[k - 1] === 0 ||\r\n                    visitedData[k1] === 0 || visitedData[k1 + 1] === 0 || visitedData[k1 - 1] === 0 ||\r\n                    visitedData[k2] === 0 || visitedData[k2 + 1] === 0 || visitedData[k2 - 1] === 0) {\r\n                    //if (visitedData[k + 1] + visitedData[k - 1] + \r\n                    //    visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +\r\n                    //    visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;\r\n                    border.push(k);\r\n                }\r\n            }\r\n\r\n        // walk through points on the boundary of the image if necessary\r\n        // if the \"black\" point is adjacent to the boundary of the image, it is a border point\r\n        if (minX == 0)\r\n            for (y = minY; y < maxY + 1; y++)\r\n                if (data[y * w] === 1)\r\n                    border.push(y * w);\r\n\r\n        if (maxX == w - 1)\r\n            for (y = minY; y < maxY + 1; y++)\r\n                if (data[y * w + maxX] === 1)\r\n                    border.push(y * w + maxX);\r\n\r\n        if (minY == 0)\r\n            for (x = minX; x < maxX + 1; x++)\r\n                if (data[x] === 1)\r\n                    border.push(x);\r\n\r\n        if (maxY == h - 1)\r\n            for (x = minX; x < maxX + 1; x++)\r\n                if (data[maxY * w + x] === 1)\r\n                    border.push(maxY * w + x);\r\n\r\n        var result = [], // border points with radius-neighbors\r\n            start, end,\r\n            endX = radius + w,\r\n            endY = radius + h,\r\n            n = radius * 2 + 1; // size of the pattern for radius-neighbors (from -r to +r with the center point)\r\n\r\n        len = border.length;\r\n        // walk through radius-neighbors of border points and add them to the result array\r\n        for (j = 0; j < len; j++) {\r\n            k = border[j]; // index of the border point\r\n            temp[k] = 1; // mark border point\r\n            result.push(k); // save the border point\r\n            x = k % w; // calc x by index\r\n            y = (k - x) / w; // calc y by index\r\n            start = radius - x > 0 ? radius - x : 0;\r\n            end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\r\n            k1 = k - radius;\r\n            // walk through x-neighbors\r\n            for (i = start; i < end; i++) {\r\n                k2 = k1 + i;\r\n                if (temp[k2] === 0) { // check the uniqueness\r\n                    temp[k2] = 1;\r\n                    result.push(k2);\r\n                }\r\n            }\r\n            start = radius - y > 0 ? radius - y : 0;\r\n            end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\r\n            k1 = k - radius * w;\r\n            // walk through y-neighbors\r\n            for (i = start; i < end; i++) {\r\n                k2 = k1 + i * w;\r\n                if (temp[k2] === 0) { // check the uniqueness\r\n                    temp[k2] = 1;\r\n                    result.push(k2);\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /** Apply the gauss-blur filter ONLY to border points with radius-neighbors\r\n      * Algorithms: http://blog.ivank.net/fastest-gaussian-blur.html\r\n      * http://www.librow.com/articles/article-9\r\n      * http://elynxsdk.free.fr/ext-docs/Blur/Fast_box_blur.pdf\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @param {int} blur radius\r\n      * @param {Uint8Array} visited: mask of visited points (optional) \r\n      * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      */\r\n    lib.gaussBlurOnlyBorder = function(mask, radius, visited) {\r\n\r\n        var border = createBorderForBlur(mask, radius, visited), // get border points with radius-neighbors\r\n            ww, dsq, i, j, k, k1, x, y, val, start, end,\r\n            n = radius * 2 + 1, // size of the pattern for radius-neighbors (from -r to +r with center point)\r\n            s2 = 2 * radius * radius,\r\n            wg = new Float32Array(n), // weights\r\n            total = 0, // sum of weights(used for normalization)\r\n            w = mask.width,\r\n            h = mask.height,\r\n            data = mask.data,\r\n            minX = mask.bounds.minX,\r\n            maxX = mask.bounds.maxX,\r\n            minY = mask.bounds.minY,\r\n            maxY = mask.bounds.maxY,\r\n            len = border.length;\r\n\r\n        // calc gauss weights\r\n        for (i = 0; i < radius; i++) {\r\n            dsq = (radius - i) * (radius - i);\r\n            ww = Math.exp(-dsq / s2) / Math.PI;\r\n            wg[radius + i] = wg[radius - i] = ww;\r\n            total += 2 * ww;\r\n        }\r\n        // normalization weights\r\n        for (i = 0; i < n; i++) {\r\n            wg[i] /= total;\r\n        }\r\n\r\n        var result = new Uint8Array(data), // copy the source mask\r\n            endX = radius + w,\r\n            endY = radius + h;\r\n\r\n        //walk through all border points for blur\r\n        for (i = 0; i < len; i++) {\r\n            k = border[i]; // index of the border point\r\n            val = 0;\r\n            x = k % w; // calc x by index\r\n            y = (k - x) / w; // calc y by index\r\n            start = radius - x > 0 ? radius - x : 0;\r\n            end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\r\n            k1 = k - radius;\r\n            // walk through x-neighbors\r\n            for (j = start; j < end; j++) {\r\n                val += data[k1 + j] * wg[j];\r\n            }\r\n            if (val > 0.5) {\r\n                result[k] = 1;\r\n                // check minmax\r\n                if (x < minX) minX = x;\r\n                if (x > maxX) maxX = x;\r\n                if (y < minY) minY = y;\r\n                if (y > maxY) maxY = y;\r\n                continue;\r\n            }\r\n            start = radius - y > 0 ? radius - y : 0;\r\n            end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\r\n            k1 = k - radius * w;\r\n            // walk through y-neighbors\r\n            for (j = start; j < end; j++) {\r\n                val += data[k1 + j * w] * wg[j];\r\n            }\r\n            if (val > 0.5) {\r\n                result[k] = 1;\r\n                // check minmax\r\n                if (x < minX) minX = x;\r\n                if (x > maxX) maxX = x;\r\n                if (y < minY) minY = y;\r\n                if (y > maxY) maxY = y;\r\n            } else {\r\n                result[k] = 0;\r\n            }\r\n        }\r\n\r\n        return {\r\n            data: result,\r\n            width: w,\r\n            height: h,\r\n            bounds: {\r\n                minX: minX,\r\n                minY: minY,\r\n                maxX: maxX,\r\n                maxY: maxY\r\n            }\r\n        };\r\n    };\r\n\r\n    /** Create a border mask (only boundary points)\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @return {Object} border mask: {Uint8Array} data, {int} width, {int} height, {Object} offset\r\n      */\r\n    lib.createBorderMask = function(mask) {\r\n\r\n        var x, y, k, k1, k2,\r\n            w = mask.width,\r\n            h = mask.height,\r\n            data = mask.data,\r\n            minX = mask.bounds.minX,\r\n            maxX = mask.bounds.maxX,\r\n            minY = mask.bounds.minY,\r\n            maxY = mask.bounds.maxY,\r\n            rw = maxX - minX + 1, // bounds size\r\n            rh = maxY - minY + 1,\r\n            result = new Uint8Array(rw * rh), // reduced mask (bounds size)\r\n            x0 = Math.max(minX, 1),\r\n            x1 = Math.min(maxX, w - 2),\r\n            y0 = Math.max(minY, 1),\r\n            y1 = Math.min(maxY, h - 2);\r\n\r\n        // walk through inner values except points on the boundary of the image\r\n        for (y = y0; y < y1 + 1; y++)\r\n            for (x = x0; x < x1 + 1; x++) {\r\n                k = y * w + x;\r\n                if (data[k] === 0) continue; // \"white\" point isn't the border\r\n                k1 = k + w; // y + 1\r\n                k2 = k - w; // y - 1\r\n                // check if any neighbor with a \"white\" color\r\n                if (data[k + 1] === 0 || data[k - 1] === 0 ||\r\n                    data[k1] === 0 || data[k1 + 1] === 0 || data[k1 - 1] === 0 ||\r\n                    data[k2] === 0 || data[k2 + 1] === 0 || data[k2 - 1] === 0) {\r\n                    //if (data[k + 1] + data[k - 1] + \r\n                    //    data[k1] + data[k1 + 1] + data[k1 - 1] +\r\n                    //    data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;\r\n                    result[(y - minY) * rw + (x - minX)] = 1;\r\n                }\r\n            }\r\n\r\n        // walk through points on the boundary of the image if necessary\r\n        // if the \"black\" point is adjacent to the boundary of the image, it is a border point\r\n        if (minX == 0)\r\n            for (y = minY; y < maxY + 1; y++)\r\n                if (data[y * w] === 1)\r\n                    result[(y - minY) * rw] = 1;\r\n\r\n        if (maxX == w - 1)\r\n            for (y = minY; y < maxY + 1; y++)\r\n                if (data[y * w + maxX] === 1)\r\n                    result[(y - minY) * rw + (maxX - minX)] = 1;\r\n\r\n        if (minY == 0)\r\n            for (x = minX; x < maxX + 1; x++)\r\n                if (data[x] === 1)\r\n                    result[x - minX] = 1;\r\n\r\n        if (maxY == h - 1)\r\n            for (x = minX; x < maxX + 1; x++)\r\n                if (data[maxY * w + x] === 1)\r\n                    result[(maxY - minY) * rw + (x - minX)] = 1;\r\n\r\n        return {\r\n            data: result,\r\n            width: rw,\r\n            height: rh,\r\n            offset: { x: minX, y: minY }\r\n        };\r\n    };\r\n    \r\n    /** Create a border index array of boundary points of the mask\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height\r\n      * @return {Array} border index array boundary points of the mask\r\n      */\r\n    lib.getBorderIndices = function(mask) {\r\n\r\n        var x, y, k, k1, k2,\r\n            w = mask.width,\r\n            h = mask.height,\r\n            data = mask.data,\r\n            border = [], // only border points\r\n            x1 = w - 1,\r\n            y1 = h - 1;\r\n\r\n        // walk through inner values except points on the boundary of the image\r\n        for (y = 1; y < y1; y++)\r\n            for (x = 1; x < x1; x++) {\r\n                k = y * w + x;\r\n                if (data[k] === 0) continue; // \"white\" point isn't the border\r\n                k1 = k + w; // y + 1\r\n                k2 = k - w; // y - 1\r\n                // check if any neighbor with a \"white\" color\r\n                if (data[k + 1] === 0 || data[k - 1] === 0 ||\r\n                    data[k1] === 0 || data[k1 + 1] === 0 || data[k1 - 1] === 0 ||\r\n                    data[k2] === 0 || data[k2 + 1] === 0 || data[k2 - 1] === 0) {\r\n                    //if (data[k + 1] + data[k - 1] + \r\n                    //    data[k1] + data[k1 + 1] + data[k1 - 1] +\r\n                    //    data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;\r\n                    border.push(k);\r\n                }\r\n            }\r\n\r\n        // walk through points on the boundary of the image if necessary\r\n        // if the \"black\" point is adjacent to the boundary of the image, it is a border point\r\n        for (y = 0; y < h; y++)\r\n            if (data[y * w] === 1)\r\n                border.push(y * w);\r\n\r\n        for (x = 0; x < w; x++)\r\n            if (data[x] === 1)\r\n                border.push(x);\r\n\r\n        k = w - 1;\r\n        for (y = 0; y < h; y++)\r\n            if (data[y * w + k] === 1)\r\n                border.push(y * w + k);\r\n\r\n        k = (h - 1) * w;\r\n        for (x = 0; x < w; x++)\r\n            if (data[k + x] === 1)\r\n                border.push(k + x);\r\n\r\n        return border;\r\n    };\r\n    \r\n    /** Create a compressed mask with a \"white\" border (1px border with zero values) for the contour tracing\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @return {Object} border mask: {Uint8Array} data, {int} width, {int} height, {Object} offset\r\n      */\r\n    function prepareMask(mask) {\r\n        var x, y,\r\n            w = mask.width,\r\n            data = mask.data,\r\n            minX = mask.bounds.minX,\r\n            maxX = mask.bounds.maxX,\r\n            minY = mask.bounds.minY,\r\n            maxY = mask.bounds.maxY,\r\n            rw = maxX - minX + 3, // bounds size +1 px on each side (a \"white\" border)\r\n            rh = maxY - minY + 3,\r\n            result = new Uint8Array(rw * rh); // reduced mask (bounds size)\r\n\r\n        // walk through inner values and copy only \"black\" points to the result mask\r\n        for (y = minY; y < maxY + 1; y++)\r\n            for (x = minX; x < maxX + 1; x++) {\r\n                if (data[y * w + x] === 1)\r\n                    result[(y - minY + 1) * rw + (x - minX + 1)] = 1;\r\n            }\r\n\r\n        return {\r\n            data: result,\r\n            width: rw,\r\n            height: rh,\r\n            offset: { x: minX - 1, y: minY - 1 }\r\n        };\r\n    };\r\n        \r\n    /** Create a contour array for the binary mask\r\n      * Algorithm: http://www.sciencedirect.com/science/article/pii/S1077314203001401\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @return {Array} contours: {Array} points, {bool} inner, {int} label\r\n      */\r\n    lib.traceContours = function(mask) {\r\n        var m = prepareMask(mask),\r\n            contours = [],\r\n            label = 0,\r\n            w = m.width,\r\n            w2 = w * 2,\r\n            h = m.height,\r\n            src = m.data,\r\n            dx = m.offset.x,\r\n            dy = m.offset.y,\r\n            dest = new Uint8Array(src), // label matrix\r\n            i, j, x, y, k, k1, c, inner, dir, first, second, current, previous, next, d;\r\n\r\n        // all [dx,dy] pairs (array index is the direction)\r\n        // 5 6 7\r\n        // 4 X 0\r\n        // 3 2 1\r\n        var directions = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];\r\n\r\n        for (y = 1; y < h - 1; y++)\r\n            for (x = 1; x < w - 1; x++) {\r\n                k = y * w + x;\r\n                if (src[k] === 1) {\r\n                    for (i = -w; i < w2; i += w2) { // k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)\r\n                        if (src[k + i] === 0 && dest[k + i] === 0) { // need contour tracing\r\n                            inner = i === w; // is inner contour tracing ?\r\n                            label++; // label for the next contour\r\n\r\n                            c = [];\r\n                            dir = inner ? 2 : 6; // start direction\r\n                            current = previous = first = { x: x, y: y };\r\n                            second = null;\r\n                            while (true) {\r\n                                dest[current.y * w + current.x] = label; // mark label for the current point \r\n                                // bypass all the neighbors around the current point in a clockwise\r\n                                for (j = 0; j < 8; j++) {\r\n                                    dir = (dir + 1) % 8;\r\n\r\n                                    // get the next point by new direction\r\n                                    d = directions[dir]; // index as direction\r\n                                    next = { x: current.x + d[0], y: current.y + d[1] };\r\n\r\n                                    k1 = next.y * w + next.x;\r\n                                    if (src[k1] === 1) // black boundary pixel\r\n                                    {\r\n                                        dest[k1] = label; // mark a label\r\n                                        break;\r\n                                    }\r\n                                    dest[k1] = -1; // mark a white boundary pixel\r\n                                    next = null;\r\n                                }\r\n                                if (next === null) break; // no neighbours (one-point contour)\r\n                                current = next;\r\n                                if (second) {\r\n                                    if (previous.x === first.x && previous.y === first.y && current.x === second.x && current.y === second.y) {\r\n                                        break; // creating the contour completed when returned to original position\r\n                                    }\r\n                                } else {\r\n                                    second = next;\r\n                                }\r\n                                c.push({ x: previous.x + dx, y: previous.y + dy });\r\n                                previous = current;\r\n                                dir = (dir + 4) % 8; // next dir (symmetrically to the current direction)\r\n                            }\r\n\r\n                            if (next != null) {\r\n                                c.push({ x: first.x + dx, y: first.y + dy }); // close the contour\r\n                                contours.push({ inner: inner, label: label, points: c }); // add contour to the list\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        return contours;\r\n    };\r\n    \r\n    /** Simplify contours\r\n      * Algorithms: http://psimpl.sourceforge.net/douglas-peucker.html \r\n      * http://neerc.ifmo.ru/wiki/index.php?title=%D0%A3%D0%BF%D1%80%D0%BE%D1%89%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE%D0%BB%D0%B8%D0%B3%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9_%D1%86%D0%B5%D0%BF%D0%B8\r\n      * @param {Array} contours: {Array} points, {bool} inner, {int} label\r\n      * @param {float} simplify tolerant\r\n      * @param {int} simplify count: min number of points when the contour is simplified\r\n      * @return {Array} contours: {Array} points, {bool} inner, {int} label, {int} initialCount\r\n      */\r\n    lib.simplifyContours = function(contours, simplifyTolerant, simplifyCount) {\r\n        var lenContours = contours.length,\r\n            result = [],\r\n            i, j, k, c, points, len, resPoints, lst, stack, ids,\r\n            maxd, maxi, dist, r1, r2, r12, dx, dy, pi, pf, pl;\r\n\r\n        // walk through all contours \r\n        for (j = 0; j < lenContours; j++) {\r\n            c = contours[j];\r\n            points = c.points;\r\n            len = c.points.length;\r\n\r\n            if (len < simplifyCount) { // contour isn't simplified\r\n                resPoints = [];\r\n                for (k = 0; k < len; k++) {\r\n                    resPoints.push({ x: points[k].x, y: points[k].y });\r\n                }\r\n                result.push({ inner: c.inner, label: c.label, points: resPoints, initialCount: len });\r\n                continue;\r\n            }\r\n\r\n            lst = [0, len - 1]; // always add first and last points\r\n            stack = [{ first: 0, last: len - 1 }]; // first processed edge\r\n\r\n            do {\r\n                ids = stack.shift();\r\n                if (ids.last <= ids.first + 1) // no intermediate points\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                maxd = -1.0; // max distance from point to current edge\r\n                maxi = ids.first; // index of maximally distant point\r\n\r\n                for (i = ids.first + 1; i < ids.last; i++) // bypass intermediate points in edge\r\n                {\r\n                    // calc the distance from current point to edge\r\n                    pi = points[i];\r\n                    pf = points[ids.first];\r\n                    pl = points[ids.last];\r\n                    dx = pi.x - pf.x;\r\n                    dy = pi.y - pf.y;\r\n                    r1 = Math.sqrt(dx * dx + dy * dy);\r\n                    dx = pi.x - pl.x;\r\n                    dy = pi.y - pl.y;\r\n                    r2 = Math.sqrt(dx * dx + dy * dy);\r\n                    dx = pf.x - pl.x;\r\n                    dy = pf.y - pl.y;\r\n                    r12 = Math.sqrt(dx * dx + dy * dy);\r\n                    if (r1 >= Math.sqrt(r2 * r2 + r12 * r12)) dist = r2;\r\n                    else if (r2 >= Math.sqrt(r1 * r1 + r12 * r12)) dist = r1;\r\n                    else dist = Math.abs((dy * pi.x - dx * pi.y + pf.x * pl.y - pl.x * pf.y) / r12);\r\n\r\n                    if (dist > maxd) {\r\n                        maxi = i; // save the index of maximally distant point\r\n                        maxd = dist;\r\n                    }\r\n                }\r\n\r\n                if (maxd > simplifyTolerant) // if the max \"deviation\" is larger than allowed then...\r\n                {\r\n                    lst.push(maxi); // add index to the simplified list\r\n                    stack.push({ first: ids.first, last: maxi }); // add the left part for processing\r\n                    stack.push({ first: maxi, last: ids.last }); // add the right part for processing\r\n                }\r\n\r\n            } while (stack.length > 0);\r\n\r\n            resPoints = [];\r\n            len = lst.length;\r\n            lst.sort(function(a, b) { return a - b; }); // restore index order\r\n            for (k = 0; k < len; k++) {\r\n                resPoints.push({ x: points[lst[k]].x, y: points[lst[k]].y }); // add result points to the correct order\r\n            }\r\n            result.push({ inner: c.inner, label: c.label, points: resPoints, initialCount: c.points.length });\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    return lib;\r\n})();\r\n\r\nif (typeof module !== \"undefined\" && module !== null) module.exports = MagicWand;\r\nif (typeof window !== \"undefined\" && window !== null) window.MagicWand = MagicWand;\r\n"],"names":[],"mappings":"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"}